package main

import (
    "bytes"
    "fmt"
    "go/format"
    "io/ioutil"
    "os"
    "strings"

    "google.golang.org/protobuf/compiler/protogen"
    "google.golang.org/protobuf/proto"
    "google.golang.org/protobuf/types/pluginpb"
)

func main() {
    // Protoc passes pluginpb.CodeGeneratorRequest in via stdin
    // marshalled with Protobuf
    input, _ := ioutil.ReadAll(os.Stdin)
    var req pluginpb.CodeGeneratorRequest
    if err := proto.Unmarshal(input, &req); err !=nil {
        panic(fmt.Errorf("failed to unmarshal input: %w", err))
    }

    // Initialise our plugin with default options
    opts := protogen.Options{}
    plugin, err := opts.New(&req)
    if err != nil {
        panic(fmt.Errorf("failed to initalise plugin: %w", err))
    }

    // Protoc passes a slice of File structs for us to process
    for _, file := range plugin.Files {
        var buf bytes.Buffer

        pkg := fmt.Sprintf(`
// Code generated by protoc-gen-oneofmapper. DO NOT EDIT.
// source: %s

package %s

`, *file.Proto.Name, file.GoPackageName)

        buf.Write([]byte(pkg))

        var hasOneofs bool
        for _, msg := range file.Proto.MessageType {
            if len(msg.OneofDecl) > 0 {
                hasOneofs = true
                oneOfs := make([]string, 0, 0)
                for _, oneofDecl := range msg.OneofDecl {
                    oneOfs = append(oneOfs, oneofDecl.GetName())
                }

                oneofTypes := make(map[string][]string)

                for _, fld := range msg.Field {
                    if fld.OneofIndex != nil {
                        oneofIndex := int(*fld.OneofIndex)
                        if oneofIndex > len(oneOfs) {
                            panic(fmt.Errorf("oneof index %d out of range", fld.OneofIndex))
                        }
                        oneofName := oneOfs[oneofIndex]

                        oneofTypes[oneofName] = append(oneofTypes[oneofName], fld.GetName())
                    }
                }

                for oneofName, oneofFields := range oneofTypes {
                    oneofName = strings.Replace(oneofName, "_", " ", -1)
                    oneofName = strings.Title(oneofName)
                    oneofName = strings.Replace(oneofName, " ", "", -1)

                    buf.Write([]byte(fmt.Sprintf("type OneOf%s string\n\n", oneofName)))
                    buf.Write([]byte("const (\n"))

                    for _, fieldName := range oneofFields {
                        fieldName = strings.Replace(fieldName, "_", " ", -1)
                        fieldName = strings.Title(fieldName)
                        fieldName = strings.Replace(fieldName, " ", "", -1)

                        buf.Write([]byte(fmt.Sprintf("%s_%s OneOf%s = \"%s\"\n", oneofName, fieldName, oneofName, fieldName)))
                    }
                    buf.Write([]byte(")"))

                    buf.Write([]byte("\n"))
                }
            }
        }

        if hasOneofs {
            filename := file.GeneratedFilenamePrefix + ".oneofmap.go"
            file := plugin.NewGeneratedFile(filename, ".")

            formatted, err := format.Source(buf.Bytes())
            if err != nil {
                panic(fmt.Errorf("failed to format the code: %w", err))
            }
            file.Write(formatted)
            // file.Write(buf.Bytes())
        }
    }

    // Generate a response from our plugin and marshall as protobuf
    stdout := plugin.Response()
    out, err := proto.Marshal(stdout)
    if err != nil {
        panic(fmt.Errorf("failed to marshal out protobuf: %w", err))
    }

    // Write the response to stdout, to be picked up by protoc
    fmt.Fprintf(os.Stdout, string(out))
}
